<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>å¤šåŠŸèƒ½åŠ å¯†è§£å¯†å·¥å…·ï¼ˆRSA å…¬é‘°/ç§é‘°ç‰ˆï¼‰</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

<style>
body {
    font-family: Segoe UI, sans-serif;
    background: #f0f4f8;
    padding: 20px;
}
.container {
    max-width: 900px;
    margin: auto;
    background: #fff;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.15);
}
h1 { text-align: center; color: #1a237e; }
label { font-weight: 600; margin-top: 15px; display: block; }
textarea, input, select {
    width: 100%;
    padding: 10px;
    margin-top: 6px;
    border-radius: 6px;
    border: 1px solid #ccc;
    box-sizing: border-box;
}
textarea { height: 110px; font-family: monospace; }
#outputText { background: #fff8e1; height: 150px; }
.keybox {
    background: #f7f7f7;
    border-left: 5px solid #007bff;
    padding: 12px;
    margin-top: 15px;
}
.button-group {
    display: flex;
    gap: 15px;
    margin-top: 20px;
}
button {
    padding: 14px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    color: white;
}
.encrypt { background: #007bff; }
.decrypt { background: #28a745; }
.keybtn { background:#6c757d; margin-top:10px; }
</style>
</head>

<body>
<div class="container">

<h1>å¤šåŠŸèƒ½åŠ å¯† / è§£å¯†å·¥å…·</h1>

<!-- RSA Key Section -->
<button class="keybtn" onclick="generateRSAKeyPair()">ğŸ”‘ ç”¢ç”Ÿ RSA å…¬é‘° / ç§é‘°</button>

<div class="keybox">
<label>RSA Public Keyï¼ˆå…¬é‘°ï¼‰</label>
<textarea id="publicKeyArea" readonly></textarea>
</div>

<div class="keybox">
<label>RSA Private Keyï¼ˆç§é‘°ï¼‰</label>
<textarea id="privateKeyArea" readonly></textarea>
</div>

<hr>

<label>1. é¸æ“‡æ–¹æ³•</label>
<select id="methodSelect">
    <option value="rsa">1. RSA å…¬é‘°åŠ å¯† / ç§é‘°è§£å¯†</option>
    <option value="caesar">2. å‡±æ’’å¯†ç¢¼</option>
    <option value="substitution">3. å–®è¡¨ç½®æ›å¯†ç¢¼</option>
    <option value="aes">4. AES å°ç¨±åŠ å¯†</option>
    <option value="xor">5. XOR åŠ å¯†</option>
</select>

<label>2. è¼¸å…¥æ–‡å­—</label>
<textarea id="inputText"></textarea>

<div id="keyField">
    <label>å°ç¨±å¼å¯†é‘°ï¼ˆAES / XOR / Substitutionï¼‰</label>
    <input type="text" id="secretKeyInput">
</div>

<div id="caesarShift">
    <label>å‡±æ’’ä½ç§»é‡ (1â€“25)</label>
    <input type="number" id="shiftValue" value="3" min="1" max="25">
</div>

<div class="button-group">
    <button class="encrypt" onclick="executeOperation('encrypt')">åŠ å¯†</button>
    <button class="decrypt" onclick="executeOperation('decrypt')">è§£å¯†</button>
</div>

<label>3. çµæœ</label>
<textarea id="outputText" readonly></textarea>

</div>

<script>
/* ================== RSA ================== */
let rsaKeyPair = null;

async function generateRSAKeyPair() {
    rsaKeyPair = await crypto.subtle.generateKey(
        {
            name: "RSA-OAEP",
            modulusLength: 2048,
            publicExponent: new Uint8Array([1,0,1]),
            hash: "SHA-256"
        },
        true,
        ["encrypt","decrypt"]
    );

    document.getElementById("publicKeyArea").value =
        await exportKey(rsaKeyPair.publicKey, "public");

    document.getElementById("privateKeyArea").value =
        await exportKey(rsaKeyPair.privateKey, "private");
}

async function exportKey(key, type) {
    const format = type === "public" ? "spki" : "pkcs8";
    const exported = await crypto.subtle.exportKey(format, key);
    const base64 = btoa(String.fromCharCode(...new Uint8Array(exported)));

    const header = type === "public"
        ? "-----BEGIN PUBLIC KEY-----"
        : "-----BEGIN PRIVATE KEY-----";
    const footer = type === "public"
        ? "-----END PUBLIC KEY-----"
        : "-----END PRIVATE KEY-----";

    return `${header}\n${base64.match(/.{1,64}/g).join("\n")}\n${footer}`;
}

/* ================== UI ================== */
const methodSelect = document.getElementById('methodSelect');
const keyField = document.getElementById('keyField');
const caesarShift = document.getElementById('caesarShift');

methodSelect.addEventListener('change', () => {
    keyField.style.display = 'none';
    caesarShift.style.display = 'none';

    if (['aes','xor','substitution'].includes(methodSelect.value)) {
        keyField.style.display = 'block';
    }
    if (methodSelect.value === 'caesar') {
        caesarShift.style.display = 'block';
    }
});
methodSelect.dispatchEvent(new Event('change'));

/* ================== æ ¸å¿ƒ ================== */
async function executeOperation(type) {
    const input = inputText.value;
    let result = '';

    try {
        switch (methodSelect.value) {
            case 'rsa':
                result = await rsaOperation(input, type);
                break;
            case 'caesar':
                result = caesarOperation(input, type, +shiftValue.value);
                break;
            case 'substitution':
                result = substitutionOperation(input, type, secretKeyInput.value);
                break;
            case 'aes':
                result = aesOperation(input, type, secretKeyInput.value);
                break;
            case 'xor':
                result = xorOperation(input, type, secretKeyInput.value);
                break;
        }
    } catch (e) {
        result = e.message;
    }
    outputText.value = result;
}

/* ================== RSA Encrypt / Decrypt ================== */
async function rsaOperation(input, type) {
    if (!rsaKeyPair) throw new Error("è«‹å…ˆç”¢ç”Ÿ RSA é‡‘é‘°");

    if (type === 'encrypt') {
        const data = new TextEncoder().encode(input);
        const encrypted = await crypto.subtle.encrypt(
            { name:"RSA-OAEP" },
            rsaKeyPair.publicKey,
            data
        );
        return btoa(String.fromCharCode(...new Uint8Array(encrypted)));
    } else {
        const bytes = Uint8Array.from(atob(input), c => c.charCodeAt(0));
        const decrypted = await crypto.subtle.decrypt(
            { name:"RSA-OAEP" },
            rsaKeyPair.privateKey,
            bytes
        );
        return new TextDecoder().decode(decrypted);
    }
}

/* ================== Other Algorithms ================== */
function caesarOperation(text, type, shift) {
    if (type === 'decrypt') shift = -shift;
    return text.toUpperCase().replace(/[A-Z]/g, c =>
        String.fromCharCode((c.charCodeAt(0)-65+shift+26)%26+65)
    );
}

function substitutionOperation(text, type, key) {
    const A='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    key=key.toUpperCase();
    if(key.length!==26) throw new Error("å¯†é‘°éœ€ 26 å­—æ¯");
    return text.toUpperCase().replace(/[A-Z]/g,c=>{
        const i=type==='encrypt'?A.indexOf(c):key.indexOf(c);
        return type==='encrypt'?key[i]:A[i];
    });
}

function aesOperation(text, type, key) {
    if(!key) throw new Error("è«‹è¼¸å…¥ AES å¯†é‘°");
    return type==='encrypt'
        ? CryptoJS.AES.encrypt(text,key).toString()
        : CryptoJS.AES.decrypt(text,key).toString(CryptoJS.enc.Utf8);
}

function xorOperation(text, type, key) {
    let r='';
    for(let i=0;i<text.length;i++){
        r+=String.fromCharCode(text.charCodeAt(i)^key.charCodeAt(i%key.length));
    }
    return type==='encrypt'?btoa(r):xorOperation(atob(text),'encrypt',key);
}
</script>
</body>
</html>
